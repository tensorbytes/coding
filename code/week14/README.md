#### 本周题目

1. [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
2. [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)




#### 个人总结

300题还有时间复杂度为 NlogN 的二分排序的思路,后面看到二分的时候需要补做

##### 300. 最长递增子序列
```

解题思路一样是 以当前节点作为末尾 去计算状态。
当前节点的状态我们只关注 以当前节点作为末尾的那个状态。

而这个状态 可能 是从前面 所有节点 变化而来( 因为求升序子序列并不要求两个元素在原数组中连续)
因此需要 遍历所有 前面状态 做比较 
for j in range(0,i):
    dp[i] = max(dp[i],dp[j]+1)

上面 dp[j] + 1  原因是 以前的状态 + 上当前节点 



```

##### 322. 零钱兑换. 
```
动态规划的问题都可以看成 要完成一件事有N步,每一步的选择项是有限的.
现在N是多少并不知道, 但是我们知道：
1、N步完成时的状态是  金币额度 >= 某个值
2、每一步的选择项 是固定的 （入参的集合）

定义状态
dp[i] = 第i步决策后的金币额度

假设入参集合是 [1,3,5], 求 组成11 额度的最少硬币数
初始状态[0]=0

第一次决策后
dp[1] 的值 可能有3个, 分别是1,3,5 因为选项是固定的,尝试使用决策项 下标类存储状态值
dp[1][0] = 1
dp[1][1] = 3
dp[1][2] = 5


第二次决策的值 只能是从第一次决策后的值演变而来

此时dp[2][0] 的值又有3个, 此时的状态值无法存储了,因此状态的定义 有问题需要重新定义


需要寻找每次决策后 状态数是固定的 定义.   以往的题目中，都是将 最少值 或者 最大值
作为 dp[i]的状态值


这里将状态定义为 dp[i] 表示为 到达i 值时 最少值也就是

dp[11] = 最少硬币数


那么dp[11] 的前一个状态 必定是 dp[11-1]  或者 dp[11 - 3] 或者 dp[11 - 5] 中值最少那个
也就是  dp[11] = min( dp[11-1] ,  dp[11 - 3] , dp[11 - 5] ) + 1


因为dp[x]的值我们不知道,只知道dp[0]、dp[1]的值为0 , 1
要求dp[11],需要先求出前面所有的 x的值

因此需要 
for i in rangr(11):
    dp[i] = min(dp[i- 1] or dp[i-3] or dp[i-5]) + 1
    
    
转化成代码如下
for i in range(11):
 for j in range(coins):
    if i - j >= 0:
        dp[i] = min(dp[i], dp[i-j] + 1) 
        
        
下面是代码中的关键地方说明：
# 这里的 dp初始化的时候 用了amount + 1 作为最大值因为 面额为1的金币数最多 = amount,
# 如果该值没有被更新, 则说明没有 能够组合成 amount 的组合存在
# 例如 金币集合为  3,5  amount = 7
# 计算 7的时候  dp[7] = min(dp[7], dp[4] or dp[2]) 而这两个值 因为 更新前的判断 2-3 小于 0, 2-5小于0 dp[2]不会被更新
# 因此dp[7] =  min(8,9)  为8 , 8 > 7 所以可以判断没有更新从而返回 -1  

```

