#### 本周题目

1. [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
2. [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)




#### 个人总结

##### 53. 最大子序和
```
leetcode的答案有个说得很好:

通常我们遍历子串或者子序列有三种遍历方式
(1)以某个节点为开头的所有子序列: 如 [a]，[a, b]，[ a, b, c] ... 再从以 b 为开头的子序列开始遍历 [b] [b, c]。

(2)根据子序列的长度为标杆，如先遍历出子序列长度为 1 的子序列，在遍历出长度为 2 的 等等。
以子序列的结束节点为基准，先遍历出以某个节点为结束的所有子序列，因为每个节点都可能会是子序列的结束节点，因此要遍历
下整个序列，如: 以 b 为结束点的所有子序列: [a , b] [b] 以 c 为结束点的所有子序列: [a, b, c] [b, c] [ c ]。

(3)第一种遍历方式通常用于暴力解法, 第二种遍历方式 leetcode (5. 最长回文子串 ) 中的解法就用到了。

第三种遍历方式 因为可以产生递推关系, 采用动态规划时, 经常通过此种遍历方式, 如 背包问题, 最大公共子串 , 这里的动态
规划解法也是以 先遍历出 以某个节点为结束节点的所有子序列 的思路对于刚接触动态规划的, 我感觉熟悉第三种遍历方式是需要抓住的核心
```

##### 122. 买卖股票的最佳时机 II
```

对于每一天,只会有两种状态,一种是持有股票,另一种是不持有股票
因此用两维数组来表示状态。

因为是要求固定天数的最大收益,最后一天的状态必须是不持有股票的.

那么不持有股票是什么情况变化得到的呢？
1、昨天没有持有股票
2、今天把昨天的股票卖了

因此每一轮步骤中需要计算dp[i][0]、dp[i][1]的值

此处还有一个疑问,为什么可以使用 dp[i][0] = max(...........)   max的方式去计算状态?
因为是求最大值,其他状态不需要保留.最终状态必定是  + prices的值,因此只有当前一个状态是最大的时候, + prices才会得到最大值。



```

